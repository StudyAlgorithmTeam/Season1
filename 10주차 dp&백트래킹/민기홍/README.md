## 파도반 수열 (9461 실버3)

아이디어:
1. 명확한 규칙성을 보이기에 점화식을 세울 수 있어 dp 알고리즘으로 풀 수 있다.
2. 입력된 testcase에 대해 가장 높은 숫자에 대해 파도반 수열 P를 구해놓으면 그보다 작은 N에 대해서는 반복적으로 점화식을 쓸 필요없이 리스트 P에 저장된 P(N)을 출력하면 된다.

풀이:

**아이디어1**

>P(1) = 1  P(2) = 1  P(3) = 1  P(4) = 2  P(5) = 2<br/>
>P(6) = 3  P(7) = 4  P(8) = 5  P(9) = 7  P(10) = 9<br/>
>...
>
>p(4) = P(1) + P(2) -> 2 = 1 + 1<br/>
>P(5) = P(2) + P(3) -> 2 = 1 + 1<br/>
>P(6) = P(3) + P(4) -> 3 = 1 + 2<br/>
>P(7) = P(4) + P(5) -> 4 = 2 + 2<br/>
>P(8) = P(5) + P(6) -> 5 = 2 + 3<br/>
>P(9) = P(6) + P(7) -> 7 = 3 + 4<br/>
>P(10) = P(7) + P(8)-> 9 = 4 + 5<br/>
>점화식 => P(N) = P(N-3) + P(N-2)

**아이디어2**

>예제) testcase = 2<br/>
>케이스1 = 6<br/>
>케이스2 = 12<br/>
>-> 이미 구해놓은 P(3) 이후부터 P(12)까지 점화식을 이용해 순차적으로 구한 후 남은 케이스인 P(6)은 점화식을 이용하지 않고 파도반 수열 리스트인 P에서 값을 가져와 출력

<br/><br/>
## 연산자 끼워넣기 (14888 실버1)

아이디어:
1. 모든 경우를 구해서 최대와 최소값을 구해야 하기에 dfs을 이용한다.

**아이디어1**

연산자에 대해 +, -, *, //를 모두 한 번씩 먼저 수행해봐야 하기에 if문을 여러개 써서 dfs 함수에 대한 재귀호출을 진행한다.<br/>
if plus:<br/>
  dfs()<br/>
if minus:<br/>
  dfs()<br/>
if multiple:<br/>
  dfs()<br/>
if divide:<br/>
  dfs()<br/>
-> 이런식으로 진행하면 모든 연산자를 수행 가능!
